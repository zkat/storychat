"use strict";

let Sequelize = require("sequelize"),
    Q = require("q"),
    _ = require("lodash"),
    proto = require("proto"),
    clone = proto.clone,
    init = proto.init,
    escape = require("sequelize/lib/sql-string").escape,
    config = require("config").db;

function connect() {
  return new Sequelize(config.database, config.username,
                       config.password, config);
}

let db = connect();
function query(q, args) {
  let deferred = Q.defer();
  /* jshint validthis: true */
  this.query(q, {}, {raw: true}, args).success(function(results) {
    deferred.resolve(results);
  }).error(function(err) {
    console.error("Error while processing query '", q, "', ", err);
    deferred.reject(err);
  });
  return deferred.promise;
}

let Transaction = clone();
init.addMethod([Transaction], function(txHandle) {
  this.txHandle = txHandle;
  this.nonce = 0;
});
Transaction.query = function() {
  return query.apply(this.txHandle, arguments);
};
Transaction.savepoint = function(name) {
  name = name? escape(name) : ("savepoint_" + this.nonce++);
  return this.query("SAVEPOINT " + name).then(_.constant(name));
};
Transaction.rollback = function(name) {
  return this.query("ROLLBACK" + name? (" TO " + escape(name)) : "");
};

function transaction(thunk) {
  let deferred = Q.defer();
  db.transaction(function(txHandle) {
    let tx =  clone(Transaction, txHandle);
    let last = thunk(tx);
    if (Q.isPromiseAlike(last)) {
      last.then(function(result) {
        txHandle.commit().success(function() {
          deferred.resolve(result);
        }).error(function(err) {
          console.error("Error while committing transaction: " + err);
          deferred.reject(err);
        });
      }, function(reason) {
        console.error("Error while completing transaction: " + reason);
        deferred.reject(reason);
        txHandle.rollback().error(function(err) {
          console.error("Error in rolling back incomplete transaction: " + err);
        });
      });
    } else {
      console.error("Transaction blocks must return a promise!");
      deferred.reject("Transaction blocks must return a promise!");
      txHandle.rollback().error(function(err) {
        console.error("Error while rolling back offending transaction: " + err);
      });
    }
  });
  return deferred.promise;
}

module.exports = {
  query: _.bind(query, db),
  transaction: transaction
};
