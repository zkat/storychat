"use strict";

let pg = require("pg"),
    Q = require("q"),
    cond = require("cond"),
    _ = require("lodash"),
    proto = require("proto"),
    clone = proto.clone,
    init = proto.init,
    escape = require("sequelize/lib/sql-string").escape,
    config = require("config").db,
    EventEmitter = require("events").EventEmitter;

let connString = (config.protocol+ "://" +
                  config.username +
                  (config.password?":"+config.password:"") +
                  "@" + config.host +
                  "/" + config.database);

let Connection = clone(EventEmitter.prototype);
init.addMethod([Connection], function(conn, client, done) {
  EventEmitter.call(conn);
  conn._client = client;
  conn._done = done;
  conn._client.on("notification", function(notification) {
    conn.emit(notification.channel, notification.payload, notification.length);
  });
  conn.on("removeListener", function(channel) {
    if (!conn.listeners(channel).length) {
      conn.query("UNLISTEN \"" + channel + "\"").fail(function(err) {
        console.error("Error unlistening on channel ", channel, ": ", err);
      });
    }
  });
  conn.on("newListener", function(channel) {
    if (!conn.listeners(channel).length) {
      conn.query("LISTEN \"" + channel + "\"").fail(function(err) {
        console.error("Error listening on channel ", channel, ": ", err);
      });
    }
  });
});
Connection.query = function(q, args, opts) {
  let conn = this;
  if (conn.isClosed) {
    cond.error("Connection is already closed");
  }
  opts = opts || {};
  args = args || [];
  if (!_.isArray(args)) {
    opts = args;
    args = [];
  }
  opts.bufferRows = opts.bufferRows === undefined ? true : opts.bufferRows;
  let deferred = Q.defer();
  conn._client.query(q, args, !opts.bufferRows ? undefined : function(e, r) {
    if (e) {
      deferred.reject(e);
    } else {
      deferred.resolve(r.rows);
    }
  }).on("row", function(row, result) {
    deferred.notify({row: row, result: result});
  }).on("error", function(err) {
    deferred.reject(err);
  }).on("end", function(result) {
    deferred.resolve(result);
  });
  return deferred.promise;
};
Connection.close = function() {
  this._done();
  this.isClosed = true;
};

function connect() {
  let deferred = Q.defer();
  pg.connect(connString, function(err, client, done) {
    if (err) {
      deferred.reject(err);
      return;
    }
    deferred.resolve(clone(Connection, client, done));
  });
  return deferred.promise;
}

let Transaction = clone();
init.addMethod([Transaction], function(transaction, conn) {
  this.conn = conn;
  this.nonce = 0;
});
Transaction.query = function() {
  return this.conn.query.apply(this.conn, arguments);
};
Transaction.savepoint = function(name) {
  name = name? escape(name) : ("savepoint_" + this.nonce++);
  return this.query("SAVEPOINT " + name).then(_.constant(name));
};
Transaction.rollback = function(name) {
  return this.query("ROLLBACK" + name? (" TO " + escape(name)) : "");
};

function transaction(thunk) {
  return connect().then(function(conn) {
    return conn.query("BEGIN").then(function() { return conn; });
  }).then(function(conn) {
    let tx =  clone(Transaction, conn);
    let last = thunk(tx);
    if (Q.isPromiseAlike(last)) {
      return last.then(function(result) {
        return conn.query("COMMIT").then(function() {
          return result;
        }, function(err) {
          console.error("Error while committing transaction: " + err);
        }).fin(function() {
          if (!conn.isClosed) {
            conn.close();
          }
        });
      }, function(reason) {
        console.error("Error completing transaction: " + reason);
        if (!conn.isClosed) {
          conn.query("ROLLBACK").fail(function(err) {
            console.error("Error rolling back incomplete transaction: ", err);
          }).fin(function() {
            if (!conn.isClosed) {
              conn.close();
            }
          });
        }
      });
    } else {
      console.error("Transaction blocks must return a promise!");
      conn.query("ROLLBACK").fail(function(err) {
        console.error("Error rolling back offending transaction: " + err);
      }).fin(function() {
        if (!conn.isClosed) {
          conn.close();
        }
      });
      return cond.error("Transaction blocks must return a promise!");
    }
  });
}

function query(q, args, opts) {
  return connect().then(function(conn) {
    return conn.query(q, args, opts).fin(function() {
      if (!conn.isClosed) {
        conn.close();
      }
    });
  });
}

module.exports = {
  query: query,
  transaction: transaction,
  connect: connect
};
