* archive [58/58]
** DONE Set up stylus for per-control styles             :style:architecture:
   CLOSED: [2013-08-25 Sun 20:23]
** DONE render chatlog and write chatlog model/list                    :chat:
   CLOSED: [2013-08-25 Sun 21:30]
   It should take care of the websocket, itself.
** DONE Move controls and models into their own directories    :architecture:
   CLOSED: [2013-08-25 Sun 21:49]
** DONE Ask around to see what people do wrt having to ../     :architecture:
   CLOSED: [2013-08-25 Sun 21:54]
   It's a bit ridiculous. Is this how node stuff usually works?...
** DONE Move node source code into src/server                  :architecture:
   CLOSED: [2013-08-25 Sun 22:12]
   Better separation this way. It's kinda awkward for the server-side code
   to live in a directory above the client code. Having src/client/js is
   ok, since it gives freedom to treat src/client as a source mirror of
   the browser-side structure.
** DONE Reconnect on disconnect, or something                          :chat:
   CLOSED: [2013-08-29 Thu 23:10]
** DONE Generic wrapper for can.Control                               :proto:
   CLOSED: [2013-08-30 Fri 00:44]
** DONE Notify the user of a disconnection somehow                     :chat:
   CLOSED: [2013-08-31 Sat 00:30]
** DONE Move websocket configuration to external param                 :chat:
   CLOSED: [2013-08-31 Sat 00:31]
   Might actually need to make a clientState thing for generic client
   settings.
   Good enough to move it out to storychat.js and pass it in.
** DONE Shared websocket connection                                    :chat:
   CLOSED: [2013-08-31 Sat 01:34]
   Ideally, there would be one websocket connection for each "thing", but
   fallback protocols mean that we can only have one WS connection open at
   any given time -- as such, the handling should be moved to a single,
   shared WS connection that is then passed around to any interested
   modules, who will receive namespaced APIs for listening/writing.
** DONE Write a transform that will include and render css            :build:
   CLOSED: [2013-08-31 Sat 12:19]
   Should be able to just require("./chatInput.styl") or
   requireCss("./chatInput.styl") and have it do the right thing. The
   question is -- should it only insert the CSS after being called the
   first time, or should control modules simply add the CSS themselves?
** DONE Write a transform for including .mustache files as can.views  :build:
   CLOSED: [2013-08-31 Sat 12:18]
** DONE Toggle between different input types in input field            :chat:
   CLOSED: [2013-09-08 Sun 15:52]
   Pressing TAB while focused on the input field should toggle between the
   different types of input.
** DONE Build all of \/static based on src\/client                    :build:
   CLOSED: [2013-09-08 Sun 16:41]
   Put everything, including regular frontend files, inside src/client/,
   and have the makefile build off there. See if watchify can be
   configured to rebuild when files in an arbitrary directory change.
** DONE Split chatbox into two components                              :chat:
   CLOSED: [2013-09-08 Sun 17:04]
   One for input, which will be increasingly complex, and one for
   rendering the actual chat entries (and interactivity with entries in
   it).
** DONE inputType dropdown                                             :chat:
   CLOSED: [2013-09-08 Sun 19:53]
   Allow a dropdown to change the inputType, not just pressing the TAB key
** DONE Add character name to chat                                     :chat:
   CLOSED: [2013-09-09 Mon 01:06]
** DONE Add dialogue                                                   :chat:
   CLOSED: [2013-09-09 Mon 02:07]
** DONE Don't lose input when you switch input types                   :chat:
   CLOSED: [2013-09-09 Mon 02:24]
   If you press tab, everything gets rerendered and the input completely
   disappears.
   The best fix for this is most likely to change how inputs
   work so that each of them is its own control, and is attached/detached
   as the types cycle through -- that way, they can maintain their state
   during tabbing.
** DONE Add actions                                                    :chat:
   CLOSED: [2013-09-09 Mon 02:36]
** DONE Get rid of system input                                        :chat:
   CLOSED: [2013-09-09 Mon 02:36]
   Because it's not supposed to be there anyway.
** DONE Get rid of 'line' input                                        :chat:
   CLOSED: [2013-09-09 Mon 02:36]
** DONE Make port configurable                                      :backend:
   CLOSED: [2013-09-09 Mon 09:04]
** DONE Log startup                                                 :backend:
   CLOSED: [2013-09-09 Mon 09:04]
   Log a message saying the server is listening and what port it's
   listening on.
** DONE Instrument messages to check timing                            :chat:
   CLOSED: [2013-09-09 Mon 09:24]
   Have a start and end timestamp right in the message which chatlog
   handles. Later on, we can use this to test latency from the server.
** DONE Add slug lines                                                 :chat:
   CLOSED: [2013-09-09 Mon 19:51]
** DONE Add scene heading                                              :chat:
   CLOSED: [2013-09-09 Mon 19:51]
** DONE Add OOC                                                        :chat:
   CLOSED: [2013-09-09 Mon 19:51]
** DONE MessageGroups                                                  :chat:
   CLOSED: [2013-09-11 Wed 00:37]
   Instead of having each item in the Chatlog be an individual message,
   have the chatlog consist of groups of messages of the same type/source
   -- so if the same source sends a message multiple times in a row, it'll
   get appended to the group. The views can then render these messages as
   multiple dom nodes, but close together so that they seem like they're
   part of a single, big message.
   Do this before styling.
** DONE Add parentheticals                                             :chat:
   CLOSED: [2013-09-11 Wed 01:11]
   This is just an extension to the dialogue input.
** DONE Style chatOutput                                         :chat:style:
   CLOSED: [2013-09-11 Wed 23:51]
** DONE Get rid of inputs that won't be used                           :chat:
   CLOSED: [2013-09-12 Thu 00:14]
   Not all the inputs listed will actually be used -- get rid of the
   irrelevant ones before doing any more work.
** DONE Basic port of smug to JS                                     :parser:
   CLOSED: [2013-09-13 Fri 00:37]
** DONE Have server send back parentheticals                    :chat:parser:
   CLOSED: [2013-09-13 Fri 01:19]
   dialogue content will be delivered as-is, and parentheticals should be
   extracted from that and sent back.
** DONE Fix parenthetical rendering                                    :chat:
   CLOSED: [2013-09-13 Fri 01:22]
** DONE Style parentheticals                                           :chat:
   CLOSED: [2013-09-13 Fri 02:04]
** DONE Move parser stuff outside of index.js                        :parser:
   CLOSED: [2013-09-13 Fri 23:21]
** DONE Write unit tests for chat parser                             :parser:
   CLOSED: [2013-09-14 Sat 15:18]
** DONE Don't crash on bad client input                              :server:
   CLOSED: [2013-09-14 Sat 15:29]
   If a malformed message is received from a client, log an error and throw
   the message away instead of crashing. This means use a catchall.
** DONE Keep tests together with source                          :organizing:
   CLOSED: [2013-09-14 Sat 15:40]
   Keep tests in the same directory as their source code and have the test
   runner find them from there.
** DONE Start structuring node code                                  :server:
   CLOSED: [2013-09-15 Sun 15:22]
   Right now, the whole damn thing is shoved into a single index.js
   file. Organize it into multiple modules. Note that we're going to use
   websockets to communicate with the client instead of AJAX!
** DONE Set up sequelize                                                 :db:
   CLOSED: [2013-09-15 Sun 21:40]
   Play with it, set up a sample migration, see how it feels. Do it in a
   branch so it's easy to throw that garbage away when it turns out it
   sucks.
** DONE Move config files to config/                                  :build:
   CLOSED: [2013-09-15 Sun 22:35]
** DONE Create a password hashing salt external to the db            :server:
   CLOSED: [2013-09-16 Mon 08:08]
   Like the sessionSecret token, create an additional salt that will be
   stored in an external config file that the system can use to improve
   the hashing for passwords.
** DONE Use node-bcrypt                                              :server:
   CLOSED: [2013-09-16 Mon 09:21]
   Instead of postgres' crypto. Things might end up in db logs this way.
** DONE Basic user API                                         :users:server:
   CLOSED: [2013-09-16 Mon 22:07]
   API for creating users and check their login credentials.
** DONE Pull in node-fibers and experiment                           :server:
   CLOSED: [2013-09-18 Wed 01:09]
** DONE Convert user tests to task module                             :tests:
   CLOSED: [2013-09-18 Wed 01:31]
** DONE Directory vars                                                 :meta:
   CLOSED: [2013-09-19 Thu 22:44]
   https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html
** DONE Switch to Q for promises                                     :server:
   CLOSED: [2013-09-19 Thu 22:54]
   https://github.com/kriskowal/q
** DONE Move sessionSecret to an external config                     :server:
   CLOSED: [2013-09-19 Thu 23:18]
** DONE rename passwordSalt to passwordSecret                       :infosec:
   CLOSED: [2013-09-19 Thu 23:22]
** DONE Extract mona into a separate project                           :mona:
   CLOSED: [2013-10-02 Wed 22:48]
   Mona lives in a separate project now, but storychat now has to pull it in as
   a dependency. :)
** DONE Move server utils into a util/ dir                            :utils:
   CLOSED: [2013-10-02 Wed 22:58]
   There's a number of different utils in the project that are just kinda
   sitting around and could potentially turn into external projects. Move them
   to a util/ folder to clean up the src/server root.
** DONE Reorganize server files                                    :refactor:
   CLOSED: [2013-10-02 Wed 23:19]
** DONE socketServer multiplexing                                    :server:
   CLOSED: [2013-10-03 Thu 00:09]
   Set up a feathers-style multiplexing system for installing services into
   socketServer that will handle different kinds of messages.
** DONE Basic pages setup with can.route                       :pages:server:
   CLOSED: [2013-10-03 Thu 23:02]
** DONE Try and get deamdify to work                                    :can:
   CLOSED: [2013-10-03 Thu 23:39]
   Basically can/amd is fucked.
* backlog [0/14]
** TODO Force scoping of control css to individual controls           :build:
   May need to hack stylify to force wrapping of stuff, or something like
   that.
** TODO Generic wrapper for can.Model                                 :proto:
** TODO Set up a basic test with testee                     :qa:architecture:
   Just something that tests that connections are established properly and
   the like.
** TODO Use Q in the frontend instead of $.deferred                  :client:
** TODO Can OTP be implemented on top of node-fibers?                :server:
** TODO Use assert properly D:                                        :tests:
   I've been putting the actual/expecteds in the wrong place. :\
** TODO Error report messages                                        :parser:
   If the parser fails, let the user know why.
** TODO Transaction support for db.js                                    :db:
** TODO Reconnect logic for socketConn                           :socketConn:
   On disconnect, try to reconnect (in the background) by polling for a
   certain amount of time. Emit a 'reconnecting' event of some sort in the
   meantime. If the timeout passes, cancel the reconnection attempt and
   emit the disconnected event.

   Add a button to the chat afterwards that allows for a manual reconnect
   attempt, so people don't have to refresh to try again.
** TODO Observable connection state                              :socketConn:
   Instead of forcing everything to attach to on* events, let them simply
   observe some kind of connectionState attribute.
** TODO Style chatInput                                          :chat:style:
   Is there a way to reuse the styles in chatOutput somehow? They're
   obviously at least partly specific to output, but the various entry
   types are supposed to look somewhat similar.
** TODO Use redis for express session storage                        :server:
   The default session storage system is neither persistent nor secure.
** TODO Secure auth for sockjs clients                       :server:infosec:
   Basically, all sockjs connections must be made using a unique token
   received from a crossdomain-safe request.
** TODO server-side rendering protocol for pages               :pages:server:
   Now that we have pushstate stuff, it should be possible (and not too hard) to
   figure out a protocol for src/client/js/pages where any pages there can
   optionally have some file or set of files, or a folder, that the server can
   look at to determine whether it can render a direct http request to that
   page.
* active [2/9]
** DONE Host canjs fork                                                 :can:
   CLOSED: [2013-10-04 Fri 19:33]
** DONE pushState/history support for pages                    :pages:server:
   CLOSED: [2013-10-04 Fri 21:40]
** TODO Login "page"                                             :login:page:
** TODO chat page                                                 :chat:page:
** TODO Improve socketServer messaging                               :server:
   Probably improve the client-side API, too. How should messages be broadcast?
   Filtered? Should raw clients be provided? Is access to the socketServer
   itself necessary? (probably).
** TODO Move proto into a shared lib                                  :proto:
** TODO Account creation page                                     :user:page:
** TODO User accounts                                          :users:server:
   Need database support for accounts with secure password hashing (just
   use postgres' support for this), a service (over websockets!) to manage
   them, and controls for creating and managing user accounts on the
   client-side.
   Look at https://github.com/chriso/node-validator for validation!
** TODO Basic character creation and management                  :characters:
   Need database support for characters, a service (over websockets?) to
   manage them, and a control on the client-side for management.
