* archive [25/25]
** DONE Set up stylus for per-control styles             :style:architecture:
   CLOSED: [2013-08-25 Sun 20:23]
** DONE render chatlog and write chatlog model/list                    :chat:
   CLOSED: [2013-08-25 Sun 21:30]
   It should take care of the websocket, itself.
** DONE Move controls and models into their own directories    :architecture:
   CLOSED: [2013-08-25 Sun 21:49]
** DONE Ask around to see what people do wrt having to ../     :architecture:
   CLOSED: [2013-08-25 Sun 21:54]
   It's a bit ridiculous. Is this how node stuff usually works?...
** DONE Move node source code into src/server                  :architecture:
   CLOSED: [2013-08-25 Sun 22:12]
   Better separation this way. It's kinda awkward for the server-side code
   to live in a directory above the client code. Having src/client/js is
   ok, since it gives freedom to treat src/client as a source mirror of
   the browser-side structure.
** DONE Reconnect on disconnect, or something                          :chat:
   CLOSED: [2013-08-29 Thu 23:10]
** DONE Generic wrapper for can.Control                               :proto:
   CLOSED: [2013-08-30 Fri 00:44]
** DONE Notify the user of a disconnection somehow                     :chat:
   CLOSED: [2013-08-31 Sat 00:30]
** DONE Move websocket configuration to external param                 :chat:
   CLOSED: [2013-08-31 Sat 00:31]
   Might actually need to make a clientState thing for generic client
   settings.
   Good enough to move it out to storychat.js and pass it in.
** DONE Shared websocket connection                                    :chat:
   CLOSED: [2013-08-31 Sat 01:34]
   Ideally, there would be one websocket connection for each "thing", but
   fallback protocols mean that we can only have one WS connection open at
   any given time -- as such, the handling should be moved to a single,
   shared WS connection that is then passed around to any interested
   modules, who will receive namespaced APIs for listening/writing.
** DONE Write a transform that will include and render css            :build:
   CLOSED: [2013-08-31 Sat 12:19]
   Should be able to just require("./chatInput.styl") or
   requireCss("./chatInput.styl") and have it do the right thing. The
   question is -- should it only insert the CSS after being called the
   first time, or should control modules simply add the CSS themselves?
** DONE Write a transform for including .mustache files as can.views  :build:
   CLOSED: [2013-08-31 Sat 12:18]
** DONE Toggle between different input types in input field            :chat:
   CLOSED: [2013-09-08 Sun 15:52]
   Pressing TAB while focused on the input field should toggle between the
   different types of input.
** DONE Build all of \/static based on src\/client                    :build:
   CLOSED: [2013-09-08 Sun 16:41]
   Put everything, including regular frontend files, inside src/client/,
   and have the makefile build off there. See if watchify can be
   configured to rebuild when files in an arbitrary directory change.
** DONE Split chatbox into two components                              :chat:
   CLOSED: [2013-09-08 Sun 17:04]
   One for input, which will be increasingly complex, and one for
   rendering the actual chat entries (and interactivity with entries in
   it).
** DONE inputType dropdown                                             :chat:
   CLOSED: [2013-09-08 Sun 19:53]
   Allow a dropdown to change the inputType, not just pressing the TAB key
** DONE Add character name to chat                                     :chat:
   CLOSED: [2013-09-09 Mon 01:06]
** DONE Add dialogue                                                   :chat:
   CLOSED: [2013-09-09 Mon 02:07]
** DONE Don't lose input when you switch input types                   :chat:
   CLOSED: [2013-09-09 Mon 02:24]
   If you press tab, everything gets rerendered and the input completely
   disappears.
   The best fix for this is most likely to change how inputs
   work so that each of them is its own control, and is attached/detached
   as the types cycle through -- that way, they can maintain their state
   during tabbing.
** DONE Add actions                                                    :chat:
   CLOSED: [2013-09-09 Mon 02:36]
** DONE Get rid of system input                                        :chat:
   CLOSED: [2013-09-09 Mon 02:36]
   Because it's not supposed to be there anyway.
** DONE Get rid of 'line' input                                        :chat:
   CLOSED: [2013-09-09 Mon 02:36]
** DONE Make port configurable                                      :backend:
   CLOSED: [2013-09-09 Mon 09:04]
** DONE Log startup                                                 :backend:
   CLOSED: [2013-09-09 Mon 09:04]
   Log a message saying the server is listening and what port it's
   listening on.
** DONE Instrument messages to check timing                            :chat:
   CLOSED: [2013-09-09 Mon 09:24]
   Have a start and end timestamp right in the message which chatlog
   handles. Later on, we can use this to test latency from the server.
* backlog [0/0]
* active [0/14]
** TODO Add slug lines                                                 :chat:
** TODO Add scene heading                                              :chat:
** TODO Add parentheticals                                             :chat:
   The input for this one is going to be a bit more complex.
** TODO Add OOC                                                        :chat:
** TODO Style chatOutput                                         :chat:style:
** TODO Style chatInput                                          :chat:style:
** TODO MessageGroups                                                  :chat:
   Instead of having each item in the Chatlog be an individual message,
   have the chatlog consist of groups of messages of the same type/source
   -- so if the same source sends a message multiple times in a row, it'll
   get appended to the group. The views can then render these messages as
   multiple dom nodes, but close together so that they seem like they're
   part of a single, big message.
** TODO Auth                                                   :chat:infosec:
** TODO Force scoping of control css to individual controls           :build:
   May need to hack stylify to force wrapping of stuff, or something like
   that.
** TODO Reconnect logic for socketConn                             :sockConn:
   Bring back the reconnection logic, but think a bit about what it means
   to reconnect and handle connected/disconnected events when there's only
   a single shared connection.
** TODO Smarter disconnect handling                                :sockConn:
   Right now, it just keeps trying to reconnect over and over, as fast as
   possible. Instead, make the reconnect frequency lower and limit the n
   number of reconnect attempts before asking the user to refresh.
** TODO Generic wrapper for can.Model                                 :proto:
** TODO Work on backend architecture                                :backend:
   When a websocket server receives a message, it should throw it into a
   0mq queue, which will be read by another server dedicated to processing
   user input. When that input is processed, a response is sent back on a
   fanout queue which goes to all websocket servers, who then send out all
   messages to appropriate clients. Might be good to key clients with some
   tag so messages can be sent selectively.
** TODO Set up a basic test with funcunit                   :qa:architecture:
   Just something that tests that connections are established properly and
   the like.
